# AI 공학

## 들어가며

2023년 챗GPT\index{챗GPT} 등장은 소프트웨어 개발 방식에 근본적인 변화를 가져왔다. 개발자들은 이제 코드를 직접 작성하는 것을 넘어 AI와 협업\index{협업}하며, 복잡한 문제를 해결하는 새로운 방법을 찾아가고 있다. 이러한 변화의 중심에는 **AI 공학\index{AI 공학}(AI Engineering)**이라는 새로운 분야가 자리잡고 있다.

AI 공학은 단순히 AI 모델을 사용하는 것을 넘어, AI 기술을 실제 제품과 서비스로 구현하는 체계적인 접근법이다. 기존의 소프트웨어 개발이 논리와 알고리즘을 중심으로 했다면, AI 공학은 데이터와 모델, 그리고 인간의 창의성을 결합하여 더 지능적이고 적응력 있는 시스템을 만들어낸다.

### 왜 AI 공학이 필요한가?

전통적인 소프트웨어 개발 방식은 명확한 한계에 직면했다. 복잡한 패턴 인식, 자연어 이해, 창의적 콘텐츠 생성과 같은 작업들은 규칙 기반 프로그래밍으로는 해결하기 어렵다. 머신러닝이 이러한 문제의 일부를 해결했지만, 여전히 대량의 레이블링된 데이터와 긴 학습 시간이 필요했다.

대규모 언어 모델\index{대규모 언어 모델}(LLM\index{LLM})의 등장은 이러한 제약을 크게 완화시켰다. 이제 개발자들은 자연어로 복잡한 작업을 수행할 수 있고, 방대한 지식을 활용하여 다양한 도메인의 문제를 해결할 수 있다. 프로토타입을 빠르게 구축하고 아이디어를 검증할 수 있으며, 코드 생성부터 문서 작성까지 개발 전 과정에서 AI의 도움을 받을 수 있다.

하지만 이러한 강력한 도구를 효과적으로 활용하려면 새로운 사고방식과 방법론이 필요하다. 바로 이것이 AI 공학이 등장한 이유다.

## 소프트웨어 패러다임 진화

소프트웨어 개발의 역사는 추상화 수준을 높여가는 과정이었다. 인간이 직접 작성하는 소프트웨어 1.0\index{소프트웨어 1.0}에서 시작하여, 데이터로부터 코드가 생성되는 머신러닝\index{머신러닝} 기반의 소프트웨어 2.0\index{소프트웨어 2.0}을 거쳐, 이제는 자연어\index{자연어}로 프로그래밍하는 소프트웨어 3.0\index{소프트웨어 3.0} 시대로 진화하고 있다. 이러한 패러다임의 변화는 테슬라의 전 AI 디렉터이자 OpenAI 창립 멤버인 Andrej Karpathy\index{Andrej Karpathy} [@karpathy2017]가 제시한 개념으로, 프로그래밍의 본질적 변화를 보여준다.

![Andrej Karpathy 소프트웨어 3.0[@karpathy2023]](images/software-3.jpg){#fig-software-3}

### 소프트웨어 1.0

소프트웨어 1.0(명시적 프로그래밍\index{명시적 프로그래밍}의 시대)은 우리가 익숙한 전통적인 프로그래밍 방식이다. 개발자가 문제를 분석하고, 알고리즘을 설계하며, 모든 로직을 명시적으로 코드로 작성한다.

``` python
def calculate_discount(price, customer_type):
    if customer_type == "premium":
        return price * 0.8
    elif customer_type == "regular":
        return price * 0.9
    else:
        return price
```

이 방식의 장점은 명확성과 예측가능성이다. 코드를 읽으면 정확히 어떤 일이 일어날지 알 수 있고, 디버깅도 상대적으로 쉽다. 하지만 복잡한 패턴이나 예외 상황을 모두 미리 예측하고 코딩해야 한다는 한계가 있다.

### 소프트웨어 2.0

Andrej Karpathy가 2017년에 제시한 소프트웨어 2.0(데이터에서 코드가 생성되는 시대)[@karpathy2017]은 프로그래밍 패러다임의 근본적 전환을 의미한다. 전통적인 방식에서 인간이 소스코드를 작성하여 바이너리로 컴파일하는 대신, 소프트웨어 2.0에서는 데이터셋을 축적하고 정제하여 신경망\index{신경망}을 훈련시키는 것이 프로그래밍의 핵심이 된다. 여기서 "소스코드"는 원하는 동작을 정의하는 데이터셋\index{데이터셋}과 대략적인 코드 골격을 제공하는 신경망 아키텍처\index{신경망 아키텍처}로 구성되며, 훈련 과정\index{훈련 과정}이 데이터셋을 최종 신경망이라는 "바이너리"로 컴파일\index{컴파일}하는 역할을 한다.

``` python
# 모델 학습
model = CustomerChurnPredictor()
model.fit(training_data, training_labels)

# 예측
churn_probability = model.predict(customer_features)
```

핵심은 신경망이 어려운 사례에서 실패할 때, 코드를 수정하는 대신 해당 사례의 라벨링된 예시를 더 추가한다는 점이다. 즉, 코드 디버깅이 아닌 **데이터 큐레이션**이 개발의 중심이 된다. 대부분의 실용적 애플리케이션에서 신경망 아키텍처와 훈련 시스템이 표준화되면서, 실제 "소프트웨어 개발"은 주로 라벨링된 데이터셋을 큐레이션하고 성장시키는 형태를 취한다. 이로 인해 개발팀도 두 그룹으로 나뉘게 된다. 데이터를 편집하고 증강하는 2.0 프로그래머(데이터 라벨러)와 주변 훈련 코드 인프라를 유지하는 소수의 1.0 프로그래머들이다.

### 소프트웨어 3.0

2023년 Andrej Karpathy가 제시한 소프트웨어 3.0(자연어가 프로그래밍 언어가 되는 시대)[@karpathy2023; @sharma2023]은 자연어 처리와 AI 기술을 활용하여 임의 길이의 입력과 출력을 처리할 수 있는 소프트웨어를 만드는 새로운 패러다임이다. 여기서 프로그래밍은 거의 언어적 연습이 되며, 간결하고 잘 명시된 영어(또는 다른 자연어)를 작성하는 것이 핵심이다. 프롬프트 엔지니어링이 새로운 프로그래밍 패러다임으로 부상하면서, 영어가 실행 가능한 언어가 되고, LLM이 런타임이 되며, 에이전트가 새로운 추상화 단위가 된다. 최근에는 프롬프트 엔지니어링을 확장한 컨텍스트 엔지니어링이 부상하고 있다.

``` python
# LLM을 활용한 고객 응대
response = llm.generate(
    prompt=f"""
    고객 문의: {customer_query}
    고객 히스토리: {customer_history}
    위 정보를 바탕으로 친절하고 도움이 되는 응답을 작성해주세요.
    """
)
```

혁신적인 점은 프롬프팅을 통해 시스템으로부터 매우 구체적인 동작을 생성할 수 있다는 것이다. 이는 곧 코딩의 정의와 일치한다. 프롬프트 엔지니어링을 사용하는 팀들은 일상적인 작업에서 40-60% 더 빠른 개발 사이클을 보이고 있으며, 몇 시간이 아닌 몇 초 만에 작동하는 코드, 테스트, 문서를 생성할 수 있다. 소프트웨어 3.0은 전통적인 코딩이나 신경망을 대체하는 것이 아니라, 이들과 공존하며 진정한 인공지능 개발에 기여한다. 오늘날 우리는 소프트웨어 1.0(클래식 프로그래밍), 2.0(신경망과 데이터 정의 로직), 3.0(영어가 인터페이스이고 LLM이 런타임이며 에이전트가 추상화 단위)이 층층이 쌓인 소프트웨어와 데이터 속에서 살고 있다.

```{r}
#| echo: false
#| label: tbl-software-paradigms
#| tbl-cap: "소프트웨어 패러다임 비교"

library(gt)
library(dplyr)

paradigm_data <- tibble(
  특성 = c("핵심 접근법", "개발자 역할", "문제 해결 방식", "핵심 자산", "변경 용이성", 
           "개발팀 구조", "디버깅 방식", "확장성", "개발 속도"),
  `소프트웨어 1.0` = c("명시적 프로그래밍", "모든 로직 직접 구현", "알고리즘 설계", "소스 코드", "코드 수정 필요",
                      "소프트웨어 엔지니어", "코드 분석 및 수정", "제한적", "느림"),
  `소프트웨어 2.0` = c("신경망/데이터 중심", "데이터 큐레이션 및 라벨링", "데이터 패턴 학습", "학습 데이터셋과 모델", "재학습 필요",
                      "2.0 프로그래머(라벨러) + 1.0 엔지니어", "데이터 추가 및 재훈련", "데이터에 의존", "중간"),
  `소프트웨어 3.0` = c("자연어 프로그래밍", "프롬프트 엔지니어링", "자연어 지시와 추론", "프롬프트와 컨텍스트", "프롬프트 수정으로 즉시 반영",
                      "AI 엔지니어 + 프롬프트 디자이너", "프롬프트 개선 및 컨텍스트 조정", "매우 높음", "매우 빠름")
)

paradigm_data %>%
  gt() %>%
  tab_header(
    title = "소프트웨어 패러다임 진화",
    subtitle = "1.0에서 3.0으로의 발전 과정"
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold"),
      cell_fill(color = "#f8f9fa")
    ),
    locations = cells_column_labels()
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold"),
      cell_fill(color = "#e9ecef")
    ),
    locations = cells_body(columns = "특성")
  ) %>%
  tab_style(
    style = cell_borders(
      sides = c("top", "bottom"),
      color = "#dee2e6",
      weight = px(1)
    ),
    locations = cells_body()
  ) %>%
  opt_table_font(
    font = list(
      google_font("Noto Sans KR"),
      default_fonts()
    )
  ) |> 
  tab_options(
    table.width = pct(100),    # 페이지 너비에 맞춤
    table.font.size = px(9)  # 글꼴 크기 소폭 축소
  ) |> 
  cols_width(
    특성 ~ pct(17),
    `소프트웨어 1.0` ~ pct(23),
    `소프트웨어 2.0` ~ pct(33),
    `소프트웨어 3.0` ~ pct(30)
  )    
```

## 데이터 과학 작업흐름 진화

전통적인 데이터 과학 워크플로우는 ETL(Extract, Transform, Load)에서 시작하여 머신러닝으로 발전했고, 이제는 AI 공학으로 진화하고 있다. 이러한 진화는 단순한 도구의 변화가 아닌, 문제 해결 방식의 근본적인 패러다임 전환을 의미한다.

```{mermaid}
%%| label: fig-data-science-evolution
%%| fig-cap: "데이터 과학 작업흐름 진화: ETL에서 AI 공학까지"
%%| fig-width: 4
%%| fig-align: center

graph LR
    subgraph ETL ["🗄️ ETL 시대 (1990-2010)"]
        E1[데이터 추출] --> E2[데이터 변환]
        E2 --> E3[데이터 적재]
        E3 --> E4[정적 리포트]
        
        style E4 fill:#ffcdd2
    end
    
    subgraph ML ["🤖 머신러닝 시대 (2010-2022)"]
        M1[데이터 수집] --> M2[전처리]
        M2 --> M3[특징 공학]
        M3 --> M4[모델 학습]
        M4 --> M5[평가/배포]
        M5 --> M6[예측/분류]
        
        style M6 fill:#c5e1a5
    end
    
    subgraph AI ["🚀 AI 공학 시대 (2022-)"]
        A1[문제 정의] --> A2[프롬프트 설계]
        A2 --> A3[즉시 프로토타입]
        A3 --> A4[피드백 수집]
        A4 --> A5[컨텍스트 최적화]
        A5 --> A6[지능형 솔루션]
        A6 --> A1
        
        style A6 fill:#81c784
    end
    
    ETL ==> ML
    ML ==> AI
    
    style ETL fill:#f5f5f5
    style ML fill:#e3f2fd
    style AI fill:#e8f5e9
```

### ETL 시대: 데이터 이동의 시대

1990년대부터 2010년대 초반까지 데이터 과학은 주로 ETL 파이프라인 구축에 집중했다. SQL과 데이터 웨어하우스가 중심이었고, 배치 처리와 정기 리포트가 주요 산출물이었다.

``` sql
-- 전통적인 ETL 예시
INSERT INTO sales_summary
SELECT 
    DATE_TRUNC('month', order_date) as month,
    SUM(amount) as total_sales,
    COUNT(*) as order_count
FROM raw_orders
WHERE order_status = 'completed'
GROUP BY DATE_TRUNC('month', order_date);
```

이 시대의 한계는 명확했다. 실시간 분석이 어렵고, 비정형 데이터 처리가 제한적이며, 인사이트 도출이 분석가의 수작업에 의존했다.

### 머신러닝 시대: 예측의 시대

2010년대에 들어서면서 머신러닝이 데이터 과학의 중심이 되었다. scikit-learn, TensorFlow 같은 프레임워크가 등장했고, 예측 모델링이 비즈니스 가치 창출의 핵심이 되었다.

``` python
# 전통적인 머신러닝 워크플로우
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

# 데이터 전처리
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)
scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)

# 모델 학습
model = RandomForestClassifier(n_estimators=100)
model.fit(X_train_scaled, y_train)

# 예측
predictions = model.predict(scaler.transform(X_test))
```

하지만 이 접근법도 한계가 있었다. 대량의 레이블링된 데이터가 필요하고, 특징 공학에 많은 시간이 소요되며, 모델 해석이 어려웠다.

### AI 공학 시대: 지능의 시대

2022년 ChatGPT 등장 이후, 데이터 과학은 AI 공학으로 진화했다. 이제는 자연어로 복잡한 분석을 수행하고, 즉시 인사이트를 도출할 수 있다.

``` python
# AI 공학 시대의 데이터 분석
response = llm.generate(
    prompt=f"""
    다음 데이터를 분석해주세요:
    {data.to_string()}
    
    1. 주요 패턴과 이상치를 찾아주세요
    2. 비즈니스 인사이트를 도출해주세요
    3. 향후 예측과 추천사항을 제시해주세요
    """,
    context=business_context
)
```

### 워크플로우 진화의 핵심 변화

```{r}
#| echo: false
#| label: tbl-workflow-comparison
#| tbl-cap: "데이터 과학 워크플로우 진화 단계별 특징"

library(gt)
library(dplyr)

workflow_data <- tibble(
  특징 = c("주요 도구", "핵심 기술", "분석 속도", "필요 인력", "주요 산출물", 
           "비정형 데이터", "자동화 수준", "인사이트 도출", "초기 투자", "유연성"),
  `ETL 시대` = c("SQL, Informatica, DataStage", "데이터베이스, 배치 처리", "일/주 단위", "ETL 개발자, DBA", "정적 리포트, 대시보드",
                 "매우 제한적", "낮음 (수동 작업)", "분석가 의존", "높음 (인프라)", "낮음"),
  `머신러닝 시대` = c("Python, R, TensorFlow", "통계, 알고리즘, 모델링", "시간/일 단위", "데이터 과학자, ML 엔지니어", "예측 모델, API",
                    "부분적 가능", "중간 (파이프라인)", "모델 기반", "중간 (인력)", "중간"),
  `AI 공학 시대` = c("LLM API, 프롬프트", "자연어 처리, 생성 AI", "실시간/분 단위", "AI 엔지니어, 프롬프트 설계자", "지능형 앱, 대화형 분석",
                   "우수 (멀티모달)", "높음 (자연어)", "AI 협업", "낮음 (API)", "매우 높음")
)

workflow_data %>%
  gt() %>%
  tab_header(
    title = "데이터 과학 워크플로우 진화의 핵심 변화",
    subtitle = "ETL → 머신러닝 → AI 공학"
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold"),
      cell_fill(color = "#f8f9fa")
    ),
    locations = cells_column_labels()
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold"),
      cell_fill(color = "#e9ecef")
    ),
    locations = cells_body(columns = "특징")
  ) %>%
  tab_style(
    style = cell_fill(color = "#ffebee"),
    locations = cells_body(columns = "ETL 시대")
  ) %>%
  tab_style(
    style = cell_fill(color = "#e3f2fd"),
    locations = cells_body(columns = "머신러닝 시대")
  ) %>%
  tab_style(
    style = cell_fill(color = "#e8f5e9"),
    locations = cells_body(columns = "AI 공학 시대")
  ) %>%
  opt_table_font(
    font = list(
      google_font("Noto Sans KR"),
      default_fonts()
    )
  ) %>%
  tab_options(
    table.width = pct(100),
    table.font.size = px(9)
  ) %>%
  cols_width(
    특징 ~ pct(18),
    `ETL 시대` ~ pct(24),
    `머신러닝 시대` ~ pct(33),
    `AI 공학 시대` ~ pct(27)
  )
```

이러한 진화는 데이터 과학자의 역할도 크게 변화시켰다. ETL 시대의 SQL 전문가에서 머신러닝 시대의 알고리즘 전문가로, 그리고 이제는 AI와 협업하는 프롬프트 설계자이자 비즈니스 문제 해결사로 진화하고 있다.

## AI 공학 개발 방법론

AI 시대의 개발 방법론은 기존의 소프트웨어 **Agile\index{Agile}**이나 데이터 과학 **CRISP-DM**과는 다른 접근이 필요하다. AI 공학은 실험과 반복, 그리고 지속적인 개선을 중심으로 한다.

### 기존 방법론 한계

Agile\index{Agile} 방법론은 소프트웨어 개발에 최적화되어 있지만, AI 시스템의 불확실성과 확률적 특성을 다루기에는 한계가 있다. 스프린트 단위로 명확한 기능을 구현하기 어렵고, 테스트의 개념도 다르게 접근해야 한다. CRISP-DM은 데이터 마이닝 프로젝트에는 적합하지만, LLM 기반 개발의 즉시성과 유연성을 충분히 활용하지 못한다. 데이터 준비와 모델링에 많은 시간을 투자하는 대신, LLM은 즉시 프로토타이핑이 가능하다.

### AI 공학 새로운 접근

AI 공학에서는 "발사하고, 준비하고, 조준한다(Fire, Ready, Aim)"는 역설적인 접근법이 효과적이다. 이는 전통적인 "준비하고, 조준하고, 발사한다"와는 정반대의 철학이다.

```{mermaid}
%%| label: fig-fire-ready-aim
%%| fig-cap: "AI 공학 접근법 비교"
%%| fig-width: 3
%%| fig-align: center
graph TD
    subgraph A [전통적 접근]
        direction LR
        A1[Ready 계획] --> A2[Aim 설계] --> A3[Fire 출시]
    end
    
    A ==> B
    
    subgraph B [AI 공학 접근]
        direction LR
        B1[Fire 프로토타입] --> B2[Ready 피드백] --> B3[Aim 최적화]
        B3 --> B1
    end
    
    style A3 fill:#ff6b6b,color:#fff
    style B1 fill:#ff6b6b,color:#fff
```

먼저 Fire(발사) 단계에서는 빠른 프로토타이핑을 진행한다. LLM을 즉시 활용해 아이디어를 검증하고 작동하는 무언가를 만든다. 완벽하지 않아도 괜찮다. 중요한 것은 실제로 작동하는 것을 빠르게 만들어 보는 것이다.

다음 Ready(준비) 단계에서는 사용자 피드백을 수집하고 분석한다. 실패 사례를 파악하고 개선점을 도출한다. 이 단계에서 실제 사용 환경에서의 데이터를 수집하고, AI의 약점을 보완할 방법을 찾는다.

마지막 Aim(조준) 단계에서는 수집된 데이터와 인사이트를 바탕으로 시스템을 최적화한다. 필요하다면 특정 도메인에 특화된 모델로 발전시키거나, 더 정교한 프롬프트 엔지니어링을 적용한다.

### AI 공학 핵심 원칙

AI-First 설계는 처음부터 AI 기능을 핵심으로 고려하는 것을 의미한다. 전통적인 로직과 AI를 적절히 조합하여 설계하고, AI가 실패했을 때를 대비한 백업 계획(fallback)을 마련해야 한다.

반복적 프롬프트 엔지니어링에서는 프롬프트를 새로운 형태의 코드로 인식한다. 프롬프트도 버전 관리\index{버전 관리}와 테스팅이 필요하며, A/B 테스트를 통한 지속적 개선이 필수적이다.

컨텍스트 중심 개발은 AI의 성능이 제공되는 컨텍스트에 크게 의존한다는 점을 인식하는 것이다. 효과적인 컨텍스트 관리 시스템을 구축하고, 도메인 지식을 체계적으로 통합해야 한다.

하이브리드 접근은 모든 것을 AI로 해결하려 하지 않는 것이다. 결정적(deterministic) 로직과 AI를 조화롭게 사용하고, 신뢰성이 중요한 부분은 전통적 방식을 유지한다.

지속적 모니터링과 개선은 AI 출력의 품질을 계속 관찰하고, 드리프트(drift)를 감지하여 대응하며, 사용자 피드백을 체계적으로 수집하고 반영하는 것을 의미한다.

## AI 엔지니어

AI 엔지니어는 단순히 AI를 사용하는 개발자가 아니다. 이들은 AI 기술과 소프트웨어 엔지니어링, 그리고 비즈니스 요구사항을 연결하는 가교 역할을 한다.

![AI 엔지니어[@swyx_alessio_2023]](images/ai-engineer.png){#fig-ai-engineer}

AI 엔지니어는 기술 스택의 중간 지점에서 다양한 역할을 수행한다. 왼쪽의 연구/데이터 영역에서는 최신 AI 모델과 기술을 이해하고 활용하며, 오른쪽의 제품/사용자 영역에서는 실제 사용자 요구사항을 AI로 해결한다.

AI 엔지니어에게 필요한 첫 번째 역량은 AI/ML 기초 지식이다. LLM의 작동 원리와 한계를 이해하고, 프롬프트 엔지니어링 기법을 숙달해야 한다. 벡터 임베딩과 유사도 검색, 파인튜닝과 RAG(Retrieval-Augmented Generation) 같은 고급 기술도 다룰 수 있어야 한다.

두 번째로 중요한 것은 소프트웨어 엔지니어링 능력이다. API 설계와 구현, 확장 가능한 시스템 아키텍처 구축, 버전 관리와 CI/CD\index{CI/CD}, 성능 최적화와 비용 관리 등 전통적인 소프트웨어 개발 역량도 갖춰야 한다.

세 번째는 도구와 프레임워크에 대한 숙련도다. LangChain, LlamaIndex, Semantic Kernel 같은 LLM 프레임워크를 다룰 수 있어야 하고, Pinecone, Weaviate, ChromaDB 등의 벡터 데이터베이스를 활용할 수 있어야 한다. 또한 다양한 LLM 제공업체의 API를 효과적으로 사용하고, Docker, Kubernetes 같은 배포 도구도 다룰 수 있어야 한다.

마지막으로 도메인 전문성도 중요하다. 비즈니스 요구사항을 이해하고, 사용자 경험을 설계하며, 윤리적 AI를 구현하고, GDPR이나 AI Act 같은 규제를 준수할 수 있어야 한다.

실제로 AI 엔지니어의 하루는 다양한 작업으로 채워진다. 아침에는 프롬프트 최적화를 통해 응답 품질을 개선하고, RAG 시스템의 검색 정확도를 향상시킨다. 오후에는 AI 기능의 A/B 테스트를 설계하고 분석하며, 비용을 모니터링하고 최적화한다. 새로운 AI 모델을 평가하고 통합하는 작업도 일상적이며, 사용자 피드백을 분석하여 개선사항을 도출하는 것도 중요한 업무다. 무엇보다 AI의 안전성과 편향성을 검토하고, 팀원들에게 AI 활용법을 교육하는 것도 AI 엔지니어의 핵심 역할이다.

```{r}
#| echo: false
#| label: tbl-role-comparison
#| tbl-cap: "AI 엔지니어와 다른 역할의 비교"

library(gt)
library(dplyr)

role_data <- tibble(
  역할 = c("데이터 과학자", "ML 엔지니어", "백엔드 개발자", "프론트엔드 개발자"),
  `주요 초점` = c("인사이트 도출", "모델 학습과 배포", "서버 로직", "사용자 인터페이스"),
  `핵심 기술` = c("통계, 분석, 시각화", "모델 최적화, MLOps", "데이터베이스, API", "UI/UX, 반응형 디자인"),
  `AI 엔지니어와 차이` = c("AI 엔지니어는 제품 구현에 집중", "AI 엔지니어는 기존 모델 활용에 집중", 
                            "AI 엔지니어는 AI 통합에 특화", "AI 엔지니어는 AI 기능 구현에 집중")
)

role_data %>%
  gt() %>%
  tab_header(
    title = "AI 엔지니어와 관련 역할 차이점"
  ) %>%
  cols_align(
    align = "center",
    columns = everything()
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold"),
      cell_fill(color = "#f8f9fa")
    ),
    locations = cells_column_labels()
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold"),
      cell_fill(color = "#e9ecef")
    ),
    locations = cells_body(columns = "역할")
  ) %>%
  tab_style(
    style = cell_borders(
      sides = c("top", "bottom"),
      color = "#dee2e6",
      weight = px(1)
    ),
    locations = cells_body()
  ) %>%
  opt_table_font(
    font = list(
      google_font("Noto Sans KR"),
      default_fonts()
    )
  ) |> 
    # 테이블 옵션
  tab_options(
    heading.title.font.size = 18,
    heading.subtitle.font.size = 14,
    table.font.size = px(9),
    data_row.padding = px(10),
    table.border.top.style = "solid",
    table.border.bottom.style = "solid",
    heading.border.bottom.style = "solid",
    column_labels.border.bottom.style = "solid",
    column_labels.border.top.style = "solid",
    table_body.border.bottom.style = "solid",
    row_group.border.top.style = "solid",
    row_group.border.bottom.style = "solid",
    table.width = pct(100)
  ) %>%
  cols_width(
    역할 ~ pct(20),
    `주요 초점` ~ pct(20),
    `핵심 기술` ~ pct(20),
    `AI 엔지니어와 차이` ~ pct(40)
  )  
```

## 데이터 과학 실무 사례

AI 공학이 데이터 과학 실무를 어떻게 변화시키는지 구체적인 사례를 통해 살펴보자. 데이터 과학의 기본 뼈대를 이루고 있는 탐색적 데이터 분석, 기계학습, 대시보드를 통해 AI 공학 접근법이 가져올 변화를 미리 경험해 보자.

### 사례 1: EDA 자동화

전통적인 탐색적 데이터 분석(EDA) 접근법과 AI 공학 접근법을 비교해보자. 과거에는 데이터 과학자가 pandas, matplotlib, seaborn 등의 라이브러리를 사용해 수십 줄의 코드를 작성하며 데이터를 탐색했다. 각 변수의 분포를 확인하고, 상관관계를 분석하고, 이상치를 찾는 모든 과정이 수동이었다. 반면 AI 공학 시대에는 자연어로 분석 목적을 설명하면 AI가 자동으로 적절한 분석을 수행하고, 인사이트를 도출하며, 필요한 시각화까지 생성한다.

``` python
# 전통적인 EDA 접근법
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

# 데이터 로드
df = pd.read_csv('sales_data.csv')

# 기본 통계
print(df.describe())
print(df.info())
print(df.isnull().sum())

# 시각화
fig, axes = plt.subplots(2, 2, figsize=(12, 10))
df['sales'].hist(ax=axes[0,0])
df.boxplot(column='sales', by='region', ax=axes[0,1])
# ... 수십 줄의 시각화 코드
```

``` python
# AI 공학 접근법
eda_report = llm.analyze(
    data=df,
    prompt="""
    이 판매 데이터에 대해 종합적인 EDA를 수행해주세요:
    1. 데이터 품질 이슈 파악
    2. 주요 패턴과 트렌드 분석
    3. 이상치와 특이사항 탐지
    4. 비즈니스 인사이트 도출
    5. 추가 분석 제안
    
    시각화가 필요한 경우 코드도 생성해주세요.
    """
)

# AI가 생성한 분석 리포트와 시각화 코드 실행
exec(eda_report.visualization_code)
print(eda_report.insights)
```

### 사례 2: 예측 모델링

머신러닝 시대와 AI 공학 시대의 예측 모델링 접근법을 비교해보자. 전통적인 머신러닝에서는 데이터 전처리부터 특징 공학, 모델 선택, 하이퍼파라미터 튜닝까지 모든 과정을 수동으로 수행해야 했다. 수십 개의 알고리즘을 테스트하고, Grid Search로 최적 파라미터를 찾고, 교차검증으로 성능을 평가하는 과정이 몇 주에서 몇 달씩 걸렸다. AI 공학에서는 문제를 자연어로 설명하면 AI가 데이터 특성을 파악하고 적절한 모델링 전략을 제안하며, AutoML과 결합하여 최적화된 모델을 자동으로 생성한다.

```{r}
#| echo: false
#| label: tbl-predictive-modeling
#| tbl-cap: "예측 모델링 접근법 비교"

library(gt)
library(dplyr)

modeling_data <- tibble(
  단계 = c("문제 정의", "데이터 준비", "특징 공학", "모델 선택", "하이퍼파라미터 튜닝", 
           "모델 평가", "해석 및 설명", "배포", "모니터링"),
  `머신러닝 접근법` = c(
    "비즈니스 요구사항을 ML 문제로 변환",
    "수동 전처리, 결측치 처리, 스케일링",
    "도메인 지식 기반 수동 특징 생성",
    "여러 알고리즘 수동 테스트",
    "Grid/Random Search로 최적화",
    "교차검증, 메트릭 계산",
    "SHAP, LIME 등 별도 도구 사용",
    "별도 배포 파이프라인 구축",
    "수동 성능 추적"
  ),
  `AI 공학 접근법` = c(
    "자연어로 문제 설명, AI가 접근법 제안",
    "AI가 데이터 이슈 자동 탐지 및 처리",
    "AI가 패턴 인식하여 특징 자동 생성",
    "AI가 데이터 특성에 맞는 모델 추천",
    "AutoML + AI 가이드 최적화",
    "AI가 종합적 평가 리포트 생성",
    "AI가 자연어로 모델 동작 설명",
    "API 기반 즉시 서비스화",
    "AI 기반 이상 탐지 및 알림"
  )
)

modeling_data %>%
  gt() %>%
  tab_header(
    title = "예측 모델링 워크플로우의 진화",
    subtitle = "머신러닝 vs AI 공학 접근법"
  ) %>%
  cols_align(
    align = "left",
    columns = c("단계", "머신러닝 접근법", "AI 공학 접근법")
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold"),
      cell_fill(color = "#f8f9fa")
    ),
    locations = cells_column_labels()
  ) %>%
  tab_style(
    style = list(
      cell_text(weight = "bold"),
      cell_fill(color = "#e9ecef")
    ),
    locations = cells_body(columns = "단계")
  ) %>%
  opt_table_font(
    font = list(
      google_font("Noto Sans KR"),
      default_fonts()
    )
  ) %>%
  tab_options(
    table.width = pct(100),
    table.font.size = px(9)
  ) %>%
  cols_width(
    단계 ~ pct(20),
    `머신러닝 접근법` ~ pct(40),
    `AI 공학 접근법` ~ pct(40)
  )
```

``` python
# 전통적인 머신러닝 접근법
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, r2_score

# 1. 데이터 전처리 (수십 줄)
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2)

# 2. 하이퍼파라미터 튜닝 (시간 소요)
param_grid = {
    'n_estimators': [100, 200, 300],
    'max_depth': [10, 20, None],
    'min_samples_split': [2, 10, 20]
}
grid_search = GridSearchCV(RandomForestRegressor(), param_grid, cv=5)
grid_search.fit(X_train, y_train)

# 3. 예측 및 평가
predictions = grid_search.predict(X_test)
print(f"RMSE: {np.sqrt(mean_squared_error(y_test, predictions))}")
```

``` python
# AI 공학 접근법
model_result = ai_ml_agent.build_model(
    data=df,
    target="customer_churn",
    prompt="""
    고객 이탈 예측 모델을 구축해주세요:
    - 데이터 품질 이슈를 자동으로 처리
    - 최적의 특징을 자동 선택
    - 여러 알고리즘을 시도하여 최고 성능 모델 선택
    - 결과를 비즈니스 언어로 설명
    - 배포 준비 완료된 API 엔드포인트 생성
    """
)

# AI가 자동으로 수행한 작업:
# - 데이터 전처리 및 특징 공학
# - 모델 선택 및 하이퍼파라미터 최적화
# - 성능 평가 및 해석
# - API 배포 준비
print(model_result.business_summary)
print(f"Model API endpoint: {model_result.api_url}")
```

### 사례 3: 실시간 대시보드

실시간 데이터 분석과 대시보드 생성에서도 AI 공학의 위력이 발휘된다. 전통적인 방식에서는 대시보드의 각 차트와 메트릭을 수동으로 설계하고, 데이터 파이프라인을 구축하며, 시각화 코드를 작성해야 했다. AI 공학에서는 비즈니스 목표를 설명하면 AI가 자동으로 관련 메트릭을 식별하고, 적절한 시각화를 생성하며, 데이터 패턴에 따라 인사이트를 실시간으로 해석해 제공한다.

``` python
# AI 공학 기반 실시간 분석 시스템
class AIAnalyticsEngine:
    def __init__(self, llm_client):
        self.llm = llm_client
        self.context_window = []
    
    def analyze_stream(self, new_data):
        # 컨텍스트에 새 데이터 추가
        self.context_window.append(new_data)
        
        # AI에게 실시간 분석 요청
        analysis = self.llm.analyze(
            context=self.context_window[-100:],  # 최근 100개 레코드
            prompt="""
            실시간 데이터 스트림을 분석하여:
            1. 현재 트렌드와 패턴 파악
            2. 이상 징후 감지
            3. 향후 30분 예측
            4. 즉각적인 조치 사항 제안
            
            JSON 형식으로 응답해주세요.
            """
        )
        
        return json.loads(analysis)
    
    def generate_insight_narrative(self, metrics):
        # AI가 메트릭을 자연어 인사이트로 변환
        narrative = self.llm.generate(
            prompt=f"""
            다음 실시간 메트릭을 비즈니스 이해관계자를 위한 
            명확하고 실행 가능한 인사이트로 변환해주세요:
            {metrics}
            
            - 핵심 발견사항 3가지
            - 권장 조치사항
            - 주의사항
            """
        )
        return narrative

# 사용 예시
engine = AIAnalyticsEngine(llm_client)
for data_point in data_stream:
    insights = engine.analyze_stream(data_point)
    narrative = engine.generate_insight_narrative(insights)
    dashboard.update(insights, narrative)
```

## 개발 작업흐름

AI 공학의 개발 작업흐름은 전통적인 소프트웨어 개발과는 다른 특징을 가진다. 선형적이고 예측 가능한 과정 대신, 실험적이고 반복적인 접근을 취한다.

![제품, 데이터, 모델 작업흐름[@swyx_alessio_2023]](images/product-data-model.png){#fig-ai-workflow fig-align="center" width="70%"}

### 아이디어 → 프로토타입 (0 → 1)

첫 단계는 아이디어를 빠르게 구현하는 것이다. 완벽하지 않아도 작동하는 것을 먼저 만들고, 실제 사용자와 빠르게 검증한다. 이 단계에서는 기술적 완성도보다 아이디어 검증에 집중한다. LLM의 강력한 능력을 활용하면 복잡한 아이디어도 몇 시간 안에 프로토타입으로 만들 수 있다.

``` python
# 빠른 프로토타입 구축 예시
def create_ai_prototype(idea, llm):
    system_prompt = f"""
    당신은 {idea}를 수행하는 AI 어시스턴트입니다.
    사용자의 요청을 이해하고 적절히 응답하세요.
    """
    
    @app.route('/api/process', methods=['POST'])
    def process_request():
        user_input = request.json['input']
        response = llm.complete(
            system_prompt=system_prompt,
            user_prompt=user_input
        )
        return {'output': response}
    
    return app
```

### 피드백 수집과 개선 (1 → 10)

프로토타입이 만들어지면 사용자 피드백을 체계적으로 수집한다. 낮은 평점을 받은 응답들을 분석하여 공통적인 실패 패턴을 찾는다. 환각(hallucination), 무관한 응답, 톤 불일치 등의 문제를 파악하고, 이를 바탕으로 프롬프트를 개선한다.

피드백 분석은 단순히 문제를 찾는 것에 그치지 않는다. 각 문제에 대한 해결책을 도출하고, 이를 시스템에 반영한다. 예를 들어 환각 문제가 발견되면 "사실과 추측을 명확히 구분하여 답변하세요"라는 지침을 추가할 수 있다.

### 규모 확장과 최적화 (10 → 100)

프로토타입이 검증되면 프로덕션 환경으로 확장한다. 이 단계에서는 캐싱, 레이트 리미팅, 비용 최적화, 병렬 처리 등의 기술적 고려사항이 중요해진다.

프로덕션 시스템은 단순히 규모만 키우는 것이 아니다. 안정성과 효율성을 동시에 추구해야 한다. Primary 모델과 fallback 모델을 준비하고, 요청의 복잡도에 따라 적절한 모델을 선택한다. 캐시를 활용하여 반복적인 요청을 효율적으로 처리하고, 비동기 처리로 성능을 최적화한다.

### 작업흐름의 핵심 도구

프롬프트 관리 시스템은 AI 공학의 핵심 도구 중 하나다. 프롬프트를 코드처럼 버전 관리하고, 테스트 케이스를 작성하여 품질을 보장한다. YAML이나 JSON 형식으로 프롬프트를 구조화하여 관리하면, 변경 이력을 추적하고 A/B 테스트를 수행하기 쉬워진다.

평가 및 모니터링 시스템도 필수적이다. AI 응답의 관련성, 일관성, 안전성, 사실성을 지속적으로 평가한다. 성능이 저하되면 즉시 알림을 보내고, 문제를 빠르게 해결할 수 있도록 한다. 응답 시간, 토큰 사용량, 사용자 만족도, 오류율 등의 메트릭을 추적하여 시스템의 건강 상태를 파악한다.

AI 공학 개발 작업흐름에서 가장 중요한 것은 사용자 중심적 접근이다. 기술적 완성도보다 실제 문제 해결에 집중하고, 빠른 실험과 검증을 통해 지속적으로 개선해나가는 것이 핵심이다. 소프트웨어 3.0 시대의 AI 엔지니어는 단순히 새로운 도구를 사용하는 것이 아니라, 문제를 해결하는 방식 자체를 재정의하는 패러다임 전환을 이끌어간다. 기술적 역량과 실험적 사고, 협업 능력과 윤리적 책임을 겸비한 AI 엔지니어가 이 강력한 도구를 현명하게 활용하여 더 나은 세상을 만들어가는 장인 역할을 담당한다.